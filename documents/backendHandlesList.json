{
  "key": "backendHandlesList",
  "value": [
    {
      "id": "BAC-001",
      "category": "認証・認可",
      "handleName": "ユーザー認証処理",
      "description": "SupabaseとFirebaseを連携したユーザー認証処理。Googleアカウントでのログインとメール/パスワード認証の両方をサポート",
      "handleProcedure": "1. クライアントからの認証リクエストを受信\n2. Firebaseでの認証を実行\n3. 認証成功時にSupabaseのユーザー情報を確認・更新\n4. JWTトークンを生成\n5. レスポンスとしてトークンとユーザー情報を返却",
      "fileName": "auth-handler.ts",
      "relatedScreen": "SCR-001",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport LoginPage from '@/app/login/page';\n\nconst mockAuthSubmit = jest.fn();\njest.mock('@/components/AuthForm', () => ({\n  __esModule: true,\n  default: ({ onSubmit }: { onSubmit: (email: string, password: string) => void }) => (\n    <div data-testid=\"mock-auth-form\">\n      <input type=\"email\" data-testid=\"email-input\" onChange={(e) => e.target.value} />\n      <input type=\"password\" data-testid=\"password-input\" onChange={(e) => e.target.value} />\n      <button onClick={() => onSubmit('test@example.com', 'password123')}>ログイン</button>\n    </div>\n  ),\n}));\n\njest.mock('@/components/Header', () => ({\n  __esModule: true,\n  default: () => <div data-testid=\"mock-header\">ヘッダー</div>,\n}));\n\njest.mock('@/components/Footer', () => ({\n  __esModule: true, \n  default: () => <div data-testid=\"mock-footer\">フッター</div>,\n}));\n\ndescribe('ログイン画面', () => {\n  beforeEach(() => {\n    mockAuthSubmit.mockClear();\n    global.mockNextRouter.push.mockClear();\n  });\n\n  test('レンダリング時に必要なコンポーネントが表示される', () => {\n    render(<LoginPage />);\n    \n    expect(screen.getByTestId('mock-header')).toBeInTheDocument();\n    expect(screen.getByTestId('mock-auth-form')).toBeInTheDocument();\n    expect(screen.getByTestId('mock-footer')).toBeInTheDocument();\n  });\n\n  test('ログイン成功時にダッシュボードへ遷移する', async () => {\n    const response = { \n      status: 200,\n      data: { token: 'dummy-token', user: { id: 1, email: 'test@example.com' } }\n    };\n    global.axios.post.mockResolvedValueOnce(response);\n\n    render(<LoginPage />);\n    \n    const loginButton = screen.getByText('ログイン');\n    await userEvent.click(loginButton);\n\n    await waitFor(() => {\n      expect(global.mockNextRouter.push).toHaveBeenCalledWith('/dashboard');\n    });\n  });\n\n  test('ログイン失敗時にエラーメッセージを表示する', async () => {\n    const error = new Error('認証エラー');\n    global.axios.post.mockRejectedValueOnce(error);\n\n    render(<LoginPage />);\n    \n    const loginButton = screen.getByText('ログイン');\n    await userEvent.click(loginButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('メールアドレスまたはパスワードが正しくありません')).toBeInTheDocument();\n    });\n  });\n\n  test('パスワードリセットリンクが正しく機能する', async () => {\n    render(<LoginPage />);\n    \n    const resetLink = screen.getByText('パスワードをお忘れの方');\n    await userEvent.click(resetLink);\n\n    expect(global.mockNextRouter.push).toHaveBeenCalledWith('/reset-password');\n  });\n\n  test('新規登録リンクが正しく機能する', async () => {\n    render(<LoginPage />);\n    \n    const signupLink = screen.getByText('新規登録はこちら');\n    await userEvent.click(signupLink);\n\n    expect(global.mockNextRouter.push).toHaveBeenCalledWith('/signup');\n  });\n\n  test('入力フィールドのバリデーションが正しく機能する', async () => {\n    render(<LoginPage />);\n    \n    const emailInput = screen.getByTestId('email-input');\n    const passwordInput = screen.getByTestId('password-input');\n    const loginButton = screen.getByText('ログイン');\n\n    await userEvent.type(emailInput, 'invalid-email');\n    await userEvent.type(passwordInput, '123');\n    await userEvent.click(loginButton);\n\n    expect(screen.getByText('有効なメールアドレスを入力してください')).toBeInTheDocument();\n    expect(screen.getByText('パスワードは8文字以上で入力してください')).toBeInTheDocument();\n  });\n\n  test('ローディング状態が正しく表示される', async () => {\n    const slowResponse = new Promise((resolve) => setTimeout(resolve, 1000));\n    global.axios.post.mockImplementationOnce(() => slowResponse);\n\n    render(<LoginPage />);\n    \n    const loginButton = screen.getByText('ログイン');\n    await userEvent.click(loginButton);\n\n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n    \n    await waitFor(() => {\n      expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();\n    });\n  });\n\n  test('認証エラー時にエラーメッセージが正しく表示される', async () => {\n    const networkError = new Error('Network Error');\n    global.axios.post.mockRejectedValueOnce(networkError);\n\n    render(<LoginPage />);\n    \n    const loginButton = screen.getByText('ログイン');\n    await userEvent.click(loginButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('通信エラーが発生しました。時間をおいて再度お試しください。')).toBeInTheDocument();\n    });\n  });\n});\n```"
    },
    {
      "id": "BAC-002",
      "category": "トレーサビリティ",
      "handleName": "QRコード生成処理",
      "description": "トレーサビリティ情報を含むQRコードの生成と管理",
      "handleProcedure": "1. クライアントから製品情報を受信\n2. トレーサビリティ情報の検証\n3. QRコードデータの生成\n4. QRコード画像の生成\n5. 生成したQRコードの保存\n6. QRコードURLの返却",
      "fileName": "qr-generator.ts",
      "relatedScreen": "SCR-012",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { act } from 'react-dom/test-utils';\nimport userEvent from '@testing-library/user-event';\nimport QRGeneratorPage from '@/app/traceability/qr-generator/page';\nimport '@testing-library/jest-dom';\nimport { useRouter } from 'next/navigation';\n\n// モック\njest.mock('@/components/Header', () => {\n  return function MockHeader() {\n    return <div data-testid=\"mock-header\">Header</div>;\n  };\n});\n\njest.mock('@/components/Sidebar', () => {\n  return function MockSidebar() {\n    return <div data-testid=\"mock-sidebar\">Sidebar</div>;\n  };\n});\n\njest.mock('@/components/QRGenerator', () => {\n  return function MockQRGenerator({ data, onGenerate }: any) {\n    return (\n      <div data-testid=\"mock-qr-generator\">\n        <button onClick={() => onGenerate(data)}>Generate QR</button>\n      </div>\n    );\n  };\n});\n\njest.mock('@/components/PrintPreview', () => {\n  return function MockPrintPreview({ content, onPrint }: any) {\n    return (\n      <div data-testid=\"mock-print-preview\">\n        <button onClick={onPrint}>Print</button>\n      </div>\n    );\n  };\n});\n\nconst mockProducts = [\n  { id: 1, name: \"Product 1\", trace_info: \"info1\" },\n  { id: 2, name: \"Product 2\", trace_info: \"info2\" }\n];\n\ndescribe('QRGeneratorPage', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn(() =>\n      Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve(mockProducts),\n      })\n    ) as jest.Mock;\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('初期レンダリング時に商品一覧を取得して表示する', async () => {\n    render(<QRGeneratorPage />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('商品を選択')).toBeInTheDocument();\n    });\n  });\n\n  it('商品選択時にQRコード生成フォームが表示される', async () => {\n    render(<QRGeneratorPage />);\n\n    await waitFor(() => {\n      const select = screen.getByRole('combobox');\n      fireEvent.change(select, { target: { value: '1' } });\n    });\n\n    expect(screen.getByTestId('mock-qr-generator')).toBeInTheDocument();\n  });\n\n  it('QRコード生成ボタンクリック時にAPIを呼び出す', async () => {\n    const mockPost = jest.spyOn(global, 'fetch');\n    render(<QRGeneratorPage />);\n\n    await waitFor(() => {\n      const select = screen.getByRole('combobox');\n      fireEvent.change(select, { target: { value: '1' } });\n    });\n\n    const generateButton = screen.getByText('Generate QR');\n    await act(async () => {\n      fireEvent.click(generateButton);\n    });\n\n    expect(mockPost).toHaveBeenCalledWith(\n      expect.stringContaining('/api/qr-codes'),\n      expect.any(Object)\n    );\n  });\n\n  it('印刷プレビューが表示される', async () => {\n    render(<QRGeneratorPage />);\n\n    await waitFor(() => {\n      const select = screen.getByRole('combobox');\n      fireEvent.change(select, { target: { value: '1' } });\n    });\n\n    const generateButton = screen.getByText('Generate QR');\n    await act(async () => {\n      fireEvent.click(generateButton);\n    });\n\n    expect(screen.getByTestId('mock-print-preview')).toBeInTheDocument();\n  });\n\n  it('エラー時にエラーメッセージを表示する', async () => {\n    global.fetch = jest.fn(() => \n      Promise.reject(new Error('API Error'))\n    ) as jest.Mock;\n\n    render(<QRGeneratorPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n    });\n  });\n\n  it('印刷ボタンクリック時に印刷ダイアログが開く', async () => {\n    global.print = jest.fn();\n    render(<QRGeneratorPage />);\n\n    await waitFor(() => {\n      const select = screen.getByRole('combobox');\n      fireEvent.change(select, { target: { value: '1' } });\n    });\n\n    const generateButton = screen.getByText('Generate QR');\n    await act(async () => {\n      fireEvent.click(generateButton);\n    });\n\n    const printButton = screen.getByText('Print');\n    fireEvent.click(printButton);\n\n    expect(global.print).toHaveBeenCalled();\n  });\n\n  it('バッチ生成モードで複数QRコードを生成できる', async () => {\n    render(<QRGeneratorPage />);\n\n    await waitFor(() => {\n      const batchModeCheckbox = screen.getByRole('checkbox', { name: 'バッチ生成モード' });\n      fireEvent.click(batchModeCheckbox);\n    });\n\n    const selectAll = screen.getByRole('checkbox', { name: '全て選択' });\n    fireEvent.click(selectAll);\n\n    const generateButton = screen.getByText('Generate QR');\n    await act(async () => {\n      fireEvent.click(generateButton);\n    });\n\n    expect(global.fetch).toHaveBeenCalledWith(\n      expect.stringContaining('/api/qr-codes/batch'),\n      expect.any(Object)\n    );\n  });\n\n  it('QRコードのダウンロードができる', async () => {\n    const mockCreateObjectURL = jest.fn();\n    global.URL.createObjectURL = mockCreateObjectURL;\n    \n    render(<QRGeneratorPage />);\n\n    await waitFor(() => {\n      const select = screen.getByRole('combobox');\n      fireEvent.change(select, { target: { value: '1' } });\n    });\n\n    const generateButton = screen.getByText('Generate QR');\n    await act(async () => {\n      fireEvent.click(generateButton);\n    });\n\n    const downloadButton = screen.getByText('ダウンロード');\n    fireEvent.click(downloadButton);\n\n    expect(mockCreateObjectURL).toHaveBeenCalled();\n  });\n});\n```"
    },
    {
      "id": "BAC-003",
      "category": "書類管理",
      "handleName": "AI書類検証処理",
      "description": "アップロードされた法的書類のAIによる内容確認と検証",
      "handleProcedure": "1. アップロードされた書類を受信\n2. OCRによるテキスト抽出\n3. AIモデルによる内容分析\n4. 法的要件との整合性チェック\n5. 検証結果レポートの生成\n6. 結果の返却",
      "fileName": "document-verification.ts",
      "relatedScreen": "SCR-014",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport userEvent from '@testing-library/user-event';\nimport AICheck from '@/app/documents/ai-check/page';\nimport axios from 'axios';\nimport { act } from 'react-dom/test-utils';\n\njest.mock('next/navigation', () => ({\n  useRouter: () => ({\n    push: jest.fn(),\n    replace: jest.fn(),\n    refresh: jest.fn(),\n  }),\n}));\n\nconst mockDocumentData = {\n  id: 'doc-1',\n  content: 'テスト文書内容',\n  status: 'pending'\n};\n\nconst mockAIResults = {\n  documentId: 'doc-1',\n  analysis: {\n    issues: [\n      {\n        type: 'warning',\n        message: '要確認項目があります',\n        location: { start: 0, end: 10 }\n      }\n    ],\n    score: 85,\n    suggestions: ['修正提案1', '修正提案2']\n  }\n};\n\ndescribe('AI書類チェック画面', () => {\n  beforeEach(() => {\n    axios.get.mockClear();\n    axios.post.mockClear();\n  });\n\n  it('画面の初期表示が正しく行われること', async () => {\n    axios.get\n      .mockResolvedValueOnce({ data: mockDocumentData })\n      .mockResolvedValueOnce({ data: mockAIResults });\n\n    await act(async () => {\n      render(<AICheck />);\n    });\n\n    expect(screen.getByText('AI書類チェック')).toBeInTheDocument();\n    expect(screen.getByTestId('document-viewer')).toBeInTheDocument();\n    expect(screen.getByTestId('ai-analyzer')).toBeInTheDocument();\n  });\n\n  it('書類アップロード機能が正しく動作すること', async () => {\n    const file = new File(['テスト文書'], 'test.pdf', { type: 'application/pdf' });\n    \n    render(<AICheck />);\n    \n    const uploadInput = screen.getByTestId('file-upload');\n    await userEvent.upload(uploadInput, file);\n\n    expect(uploadInput.files[0]).toBe(file);\n    expect(screen.getByText('アップロード完了')).toBeInTheDocument();\n  });\n\n  it('AI分析結果が正しく表示されること', async () => {\n    axios.get\n      .mockResolvedValueOnce({ data: mockDocumentData })\n      .mockResolvedValueOnce({ data: mockAIResults });\n\n    await act(async () => {\n      render(<AICheck />);\n    });\n\n    expect(screen.getByText('要確認項目があります')).toBeInTheDocument();\n    expect(screen.getByText('スコア: 85')).toBeInTheDocument();\n  });\n\n  it('承認/却下機能が正しく動作すること', async () => {\n    axios.post.mockResolvedValue({ data: { status: 'approved' } });\n\n    render(<AICheck />);\n\n    const approveButton = screen.getByText('承認');\n    await userEvent.click(approveButton);\n\n    expect(axios.post).toHaveBeenCalledWith(\n      expect.any(String),\n      expect.objectContaining({\n        documentId: 'doc-1',\n        status: 'approved'\n      })\n    );\n  });\n\n  it('エラー発生時にエラーメッセージが表示されること', async () => {\n    axios.get.mockRejectedValue(new Error('データ取得に失敗しました'));\n\n    await act(async () => {\n      render(<AICheck />);\n    });\n\n    expect(screen.getByText('エラーが発生しました')).toBeInTheDocument();\n  });\n\n  it('修正提案が正しく表示され、適用できること', async () => {\n    axios.get\n      .mockResolvedValueOnce({ data: mockDocumentData })\n      .mockResolvedValueOnce({ data: mockAIResults });\n\n    await act(async () => {\n      render(<AICheck />);\n    });\n\n    expect(screen.getByText('修正提案1')).toBeInTheDocument();\n    \n    const applySuggestionButton = screen.getByText('修正を適用');\n    await userEvent.click(applySuggestionButton);\n\n    expect(screen.getByText('修正が適用されました')).toBeInTheDocument();\n  });\n\n  it('AI分析の再実行が可能であること', async () => {\n    render(<AICheck />);\n\n    const reanalyzeButton = screen.getByText('再分析');\n    await userEvent.click(reanalyzeButton);\n\n    expect(axios.post).toHaveBeenCalledWith(\n      expect.any(String),\n      expect.objectContaining({\n        action: 'reanalyze',\n        documentId: expect.any(String)\n      })\n    );\n  });\n\n  it('ハイライト表示の切り替えが可能であること', async () => {\n    render(<AICheck />);\n\n    const highlightToggle = screen.getByRole('switch', { name: 'ハイライト表示' });\n    await userEvent.click(highlightToggle);\n\n    expect(screen.getByTestId('document-viewer')).toHaveAttribute('data-highlight', 'true');\n  });\n});\n```"
    },
    {
      "id": "BAC-004",
      "category": "決済管理",
      "handleName": "決済処理",
      "description": "外部決済サービスと連携した決済処理の実行",
      "handleProcedure": "1. 決済リクエストの受信\n2. 決済情報の検証\n3. 外部決済サービスへのリクエスト\n4. 決済結果の確認\n5. 取引記録の更新\n6. 決済結果の返却",
      "fileName": "payment-processor.ts",
      "relatedScreen": "SCR-009",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { jest } from '@jest/globals';\nimport userEvent from '@testing-library/user-event';\nimport '@testing-library/jest-dom';\nimport PaymentsPage from '@/app/payments/index/page';\n\n// モックデータ\nconst mockPayments = [\n  {\n    id: 'p1',\n    amount: 10000,\n    status: '完了',\n    date: '2024-01-01',\n    paymentMethod: 'クレジットカード'\n  },\n  {\n    id: 'p2', \n    amount: 20000,\n    status: '保留中',\n    date: '2024-01-02',\n    paymentMethod: '銀行振込'\n  }\n];\n\nconst mockTransactions = [\n  {\n    id: 't1',\n    type: '入金',\n    amount: 10000,\n    date: '2024-01-01'\n  },\n  {\n    id: 't2',\n    type: '出金', \n    amount: 5000,\n    date: '2024-01-02'\n  }\n];\n\n// モック\njest.mock('@/app/components/Header', () => {\n  return function MockHeader() {\n    return <div data-testid=\"mock-header\">Header</div>;\n  };\n});\n\njest.mock('@/app/components/Sidebar', () => {\n  return function MockSidebar() {\n    return <div data-testid=\"mock-sidebar\">Sidebar</div>;\n  };\n});\n\njest.mock('axios');\n\ndescribe('PaymentsPage', () => {\n  beforeEach(() => {\n    global.axios.get.mockImplementation((url) => {\n      if (url.includes('payments')) {\n        return Promise.resolve({ data: mockPayments });\n      }\n      if (url.includes('transactions')) {\n        return Promise.resolve({ data: mockTransactions });\n      }\n    });\n  });\n\n  afterEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('ページが正しくレンダリングされること', async () => {\n    render(<PaymentsPage />);\n\n    expect(screen.getByTestId('mock-header')).toBeInTheDocument();\n    expect(screen.getByTestId('mock-sidebar')).toBeInTheDocument();\n    expect(screen.getByText('決済一覧')).toBeInTheDocument();\n  });\n\n  it('決済データが正しく表示されること', async () => {\n    render(<PaymentsPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('¥10,000')).toBeInTheDocument();\n      expect(screen.getByText('完了')).toBeInTheDocument();\n      expect(screen.getByText('クレジットカード')).toBeInTheDocument();\n    });\n  });\n\n  it('フィルターが正しく機能すること', async () => {\n    render(<PaymentsPage />);\n    \n    const filterSelect = screen.getByLabelText('決済状況');\n    await userEvent.selectOptions(filterSelect, '完了');\n\n    await waitFor(() => {\n      expect(screen.getByText('完了')).toBeInTheDocument();\n      expect(screen.queryByText('保留中')).not.toBeInTheDocument();\n    });\n  });\n\n  it('入出金履歴が正しく表示されること', async () => {\n    render(<PaymentsPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('入金')).toBeInTheDocument();\n      expect(screen.getByText('¥10,000')).toBeInTheDocument();\n      expect(screen.getByText('2024-01-01')).toBeInTheDocument();\n    });\n  });\n\n  it('明細ダウンロードボタンが機能すること', async () => {\n    const mockDownload = jest.fn();\n    global.URL.createObjectURL = jest.fn();\n    global.URL.revokeObjectURL = jest.fn();\n    \n    render(<PaymentsPage />);\n    \n    const downloadButton = screen.getByText('明細ダウンロード');\n    await userEvent.click(downloadButton);\n\n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith('/api/payments/download');\n    });\n  });\n\n  it('日付範囲フィルターが機能すること', async () => {\n    render(<PaymentsPage />);\n\n    const startDateInput = screen.getByLabelText('開始日');\n    const endDateInput = screen.getByLabelText('終了日');\n\n    await userEvent.type(startDateInput, '2024-01-01');\n    await userEvent.type(endDateInput, '2024-01-02');\n\n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith(\n        expect.stringContaining('startDate=2024-01-01')\n      );\n    });\n  });\n\n  it('エラー状態が適切に表示されること', async () => {\n    global.axios.get.mockRejectedValueOnce(new Error('API Error'));\n    \n    render(<PaymentsPage />);\n\n    await waitFor(() => {\n      expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  it('ページネーションが機能すること', async () => {\n    render(<PaymentsPage />);\n\n    const nextPageButton = screen.getByLabelText('次のページ');\n    await userEvent.click(nextPageButton);\n\n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith(\n        expect.stringContaining('page=2')\n      );\n    });\n  });\n\n  it('決済詳細モーダルが表示されること', async () => {\n    render(<PaymentsPage />);\n\n    const detailButton = screen.getByText('詳細を見る');\n    await userEvent.click(detailButton);\n\n    await waitFor(() => {\n      expect(screen.getByText('決済詳細')).toBeInTheDocument();\n      expect(screen.getByText('クレジットカード')).toBeInTheDocument();\n      expect(screen.getByText('¥10,000')).toBeInTheDocument();\n    });\n  });\n});\n```"
    },
    {
      "id": "BAC-005",
      "category": "データ分析",
      "handleName": "需要予測処理",
      "description": "AIを使用した商品需要予測の分析と結果生成",
      "handleProcedure": "1. 過去の取引データの収集\n2. データの前処理と正規化\n3. AIモデルによる需要予測\n4. 予測結果の検証\n5. レポートの生成\n6. 分析結果の返却",
      "fileName": "demand-forecast.ts",
      "relatedScreen": "SCR-015",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport { act } from 'react-dom/test-utils';\nimport DemandForecast from '@/app/analytics/demand-forecast/page';\nimport userEvent from '@testing-library/user-event';\nimport { jest } from '@jest/globals';\n\n// モックデータ\nconst mockForecastData = {\n  dates: ['2024-01', '2024-02', '2024-03'],\n  values: [100, 120, 140],\n  predictions: [150, 160, 170]\n};\n\nconst mockSalesData = {\n  history: [\n    { date: '2023-12', amount: 90 },\n    { date: '2023-11', amount: 85 },\n    { date: '2023-10', amount: 95 }\n  ]\n};\n\n// APIモック\njest.mock('axios', () => ({\n  get: jest.fn(() => Promise.resolve({ data: mockSalesData })),\n  post: jest.fn(() => Promise.resolve({ data: mockForecastData }))\n}));\n\ndescribe('DemandForecast', () => {\n  beforeEach(() => {\n    jest.clearAllMocks();\n  });\n\n  it('初期レンダリング時に必要なコンポーネントが表示される', async () => {\n    render(<DemandForecast />);\n\n    expect(screen.getByText('需要予測')).toBeInTheDocument();\n    expect(screen.getByRole('button', { name: '予測実行' })).toBeInTheDocument();\n    expect(screen.getByLabelText('分析期間')).toBeInTheDocument();\n    expect(screen.getByLabelText('予測モデル')).toBeInTheDocument();\n  });\n\n  it('パラメータ入力後に予測が実行される', async () => {\n    render(<DemandForecast />);\n\n    const periodSelect = screen.getByLabelText('分析期間');\n    const modelSelect = screen.getByLabelText('予測モデル');\n    const executeButton = screen.getByRole('button', { name: '予測実行' });\n\n    await act(async () => {\n      await userEvent.selectOptions(periodSelect, '6');\n      await userEvent.selectOptions(modelSelect, 'arima');\n      fireEvent.click(executeButton);\n    });\n\n    await waitFor(() => {\n      expect(global.axios.post).toHaveBeenCalledWith(\n        '/api/forecasts/predict',\n        expect.any(Object)\n      );\n    });\n  });\n\n  it('エラー時にエラーメッセージが表示される', async () => {\n    global.axios.post.mockRejectedValueOnce(new Error('予測に失敗しました'));\n    \n    render(<DemandForecast />);\n    \n    const executeButton = screen.getByRole('button', { name: '予測実行' });\n\n    await act(async () => {\n      fireEvent.click(executeButton);\n    });\n\n    await waitFor(() => {\n      expect(screen.getByText('予測の実行に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  it('グラフが正しく表示される', async () => {\n    render(<DemandForecast />);\n    \n    await act(async () => {\n      fireEvent.click(screen.getByRole('button', { name: '予測実行' }));\n    });\n\n    await waitFor(() => {\n      expect(screen.getByTestId('forecast-chart')).toBeInTheDocument();\n    });\n  });\n\n  it('CSVエクスポートが機能する', async () => {\n    const mockCreateObjectURL = jest.fn();\n    global.URL.createObjectURL = mockCreateObjectURL;\n    \n    render(<DemandForecast />);\n    \n    await act(async () => {\n      fireEvent.click(screen.getByRole('button', { name: '予測実行' }));\n    });\n\n    await waitFor(() => {\n      const exportButton = screen.getByRole('button', { name: 'CSVエクスポート' });\n      fireEvent.click(exportButton);\n      expect(mockCreateObjectURL).toHaveBeenCalled();\n    });\n  });\n\n  it('パラメータバリデーションが機能する', async () => {\n    render(<DemandForecast />);\n\n    const executeButton = screen.getByRole('button', { name: '予測実行' });\n\n    await act(async () => {\n      fireEvent.click(executeButton);\n    });\n\n    expect(screen.getByText('分析期間を選択してください')).toBeInTheDocument();\n    expect(screen.getByText('予測モデルを選択してください')).toBeInTheDocument();\n  });\n\n  it('ローディング状態が表示される', async () => {\n    render(<DemandForecast />);\n\n    const executeButton = screen.getByRole('button', { name: '予測実行' });\n\n    await act(async () => {\n      fireEvent.click(executeButton);\n    });\n\n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n  });\n});\n```"
    },
    {
      "id": "BAC-006",
      "category": "システム管理",
      "handleName": "不正アクセス検知処理",
      "description": "システムへの不正アクセスやアカウント乗っ取りの検知",
      "handleProcedure": "1. アクセスログの収集\n2. 不正パターンの分析\n3. リスクスコアの計算\n4. 不正アクセスの判定\n5. アラートの生成\n6. セキュリティログの更新",
      "fileName": "security-monitor.ts",
      "relatedScreen": "SCR-011",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { jest } from '@jest/globals';\nimport UsersPage from '@/app/admin/users/page';\nimport { Header } from '@/components/Header';\nimport { Sidebar } from '@/components/Sidebar';\n\n// モック\njest.mock('@/components/Header', () => ({\n  Header: () => <div data-testid=\"header\">Header</div>\n}));\n\njest.mock('@/components/Sidebar', () => ({\n  Sidebar: () => <div data-testid=\"sidebar\">Sidebar</div>\n}));\n\nconst mockUsers = [\n  {\n    id: '1',\n    email: 'test1@example.com',\n    role: 'admin',\n    status: 'active',\n    companyName: 'Test Company 1'\n  },\n  {\n    id: '2', \n    email: 'test2@example.com',\n    role: 'user',\n    status: 'inactive',\n    companyName: 'Test Company 2'\n  }\n];\n\nconst mockRoles = [\n  { id: 1, name: 'admin' },\n  { id: 2, name: 'user' }\n];\n\ndescribe('UsersPage', () => {\n  beforeEach(() => {\n    global.fetch = jest.fn((url) => {\n      if (url.includes('/api/users')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve({ users: mockUsers })\n        });\n      }\n      if (url.includes('/api/roles')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve({ roles: mockRoles })\n        });\n      }\n      return Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve({})\n      });\n    }) as jest.Mock;\n  });\n\n  it('ページが正しくレンダリングされること', async () => {\n    render(<UsersPage />);\n    \n    expect(screen.getByTestId('header')).toBeInTheDocument();\n    expect(screen.getByTestId('sidebar')).toBeInTheDocument();\n    expect(screen.getByText('ユーザー管理')).toBeInTheDocument();\n    \n    await waitFor(() => {\n      expect(screen.getByText('test1@example.com')).toBeInTheDocument();\n    });\n  });\n\n  it('ユーザー検索が正しく動作すること', async () => {\n    render(<UsersPage />);\n    \n    const searchInput = screen.getByPlaceholderText('ユーザーを検索');\n    await userEvent.type(searchInput, 'test1');\n    \n    await waitFor(() => {\n      expect(screen.getByText('test1@example.com')).toBeInTheDocument();\n      expect(screen.queryByText('test2@example.com')).not.toBeInTheDocument();\n    });\n  });\n\n  it('ユーザーの権限変更が正しく動作すること', async () => {\n    render(<UsersPage />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('test1@example.com')).toBeInTheDocument();\n    });\n\n    const roleSelect = screen.getAllByRole('combobox')[0];\n    await userEvent.selectOptions(roleSelect, 'user');\n\n    expect(fetch).toHaveBeenCalledWith('/api/users/1', {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ role: 'user' })\n    });\n  });\n\n  it('ユーザーのステータス変更が正しく動作すること', async () => {\n    render(<UsersPage />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('test1@example.com')).toBeInTheDocument();\n    });\n\n    const statusToggle = screen.getAllByRole('switch')[0];\n    await userEvent.click(statusToggle);\n\n    expect(fetch).toHaveBeenCalledWith('/api/users/1', {\n      method: 'PATCH',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({ status: 'inactive' })\n    });\n  });\n\n  it('エラー時にエラーメッセージが表示されること', async () => {\n    global.fetch = jest.fn().mockRejectedValueOnce(new Error('API Error'));\n    \n    render(<UsersPage />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  it('不正アクセス検知アラートが表示されること', async () => {\n    global.fetch = jest.fn((url) => {\n      if (url.includes('/api/security/alerts')) {\n        return Promise.resolve({\n          ok: true,\n          json: () => Promise.resolve({ \n            alerts: [{ \n              id: 1,\n              type: 'suspicious_access',\n              userId: '1',\n              timestamp: new Date().toISOString()\n            }]\n          })\n        });\n      }\n      return Promise.resolve({\n        ok: true,\n        json: () => Promise.resolve({ users: mockUsers })\n      });\n    }) as jest.Mock;\n\n    render(<UsersPage />);\n    \n    await waitFor(() => {\n      expect(screen.getByText('不正アクセスの可能性があります')).toBeInTheDocument();\n    });\n  });\n});\n```"
    },
    {
      "id": "BAC-007",
      "category": "トレーサビリティ",
      "handleName": "流通履歴更新処理",
      "description": "製品の流通過程における位置情報と状態の更新処理",
      "handleProcedure": "1. 位置情報データの受信\n2. データの検証\n3. トレーサビリティ情報の更新\n4. 関連製品の状態更新\n5. 更新履歴の記録\n6. 更新結果の返却",
      "fileName": "trace-updater.ts",
      "relatedScreen": "SCR-003",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react';\nimport userEvent from '@testing-library/user-event';\nimport { act } from 'react-dom/test-utils';\nimport TraceabilityList from '@/app/traceability/index/page';\n\n// モックデータ\nconst mockTraceData = [\n  {\n    id: '1',\n    productId: 'p1',\n    lotNumber: 'LOT001',\n    productName: 'CBD Oil',\n    status: '流通中',\n    updatedAt: '2024-01-01'\n  },\n  {\n    id: '2', \n    productId: 'p2',\n    lotNumber: 'LOT002',\n    productName: 'CBD Cream',\n    status: '出荷済み',\n    updatedAt: '2024-01-02'\n  }\n];\n\n// モックの定義\njest.mock('@/components/Header', () => ({\n  __esModule: true,\n  default: () => <div data-testid=\"header\" />\n}));\n\njest.mock('@/components/Sidebar', () => ({\n  __esModule: true, \n  default: () => <div data-testid=\"sidebar\" />\n}));\n\njest.mock('@/components/SearchFilter', () => ({\n  __esModule: true,\n  default: ({ onFilter }: { onFilter: (filters: any) => void }) => (\n    <div data-testid=\"search-filter\">\n      <button onClick={() => onFilter({ keyword: 'test' })}>Filter</button>\n    </div>\n  )\n}));\n\njest.mock('@/components/Pagination', () => ({\n  __esModule: true,\n  default: ({ onPageChange }: { onPageChange: (page: number) => void }) => (\n    <div data-testid=\"pagination\">\n      <button onClick={() => onPageChange(2)}>Next</button>\n    </div>\n  )\n}));\n\n// APIコールのモック\njest.mock('axios');\n\ndescribe('トレーサビリティ情報一覧画面', () => {\n  beforeEach(() => {\n    // APIレスポンスのモック\n    (global.axios.get as jest.Mock).mockResolvedValue({\n      data: {\n        items: mockTraceData,\n        total: 2\n      }\n    });\n  });\n\n  it('初期レンダリング時に必要なコンポーネントが表示される', async () => {\n    render(<TraceabilityList />);\n    \n    expect(screen.getByTestId('header')).toBeInTheDocument();\n    expect(screen.getByTestId('sidebar')).toBeInTheDocument();\n    expect(screen.getByTestId('search-filter')).toBeInTheDocument();\n    expect(screen.getByTestId('pagination')).toBeInTheDocument();\n    expect(screen.getByText('新規登録')).toBeInTheDocument();\n  });\n\n  it('トレーサビリティデータが正しく表示される', async () => {\n    render(<TraceabilityList />);\n\n    await waitFor(() => {\n      expect(screen.getByText('LOT001')).toBeInTheDocument();\n      expect(screen.getByText('CBD Oil')).toBeInTheDocument();\n      expect(screen.getByText('LOT002')).toBeInTheDocument();\n      expect(screen.getByText('CBD Cream')).toBeInTheDocument();\n    });\n  });\n\n  it('検索フィルターが正しく動作する', async () => {\n    render(<TraceabilityList />);\n\n    const filterButton = screen.getByText('Filter');\n    fireEvent.click(filterButton);\n\n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith(\n        expect.stringContaining('keyword=test')\n      );\n    });\n  });\n\n  it('ページネーションが正しく動作する', async () => {\n    render(<TraceabilityList />);\n\n    const nextButton = screen.getByText('Next');\n    fireEvent.click(nextButton);\n\n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith(\n        expect.stringContaining('page=2')\n      );\n    });\n  });\n\n  it('新規登録ボタンクリック時に画面遷移する', async () => {\n    render(<TraceabilityList />);\n\n    const registerButton = screen.getByText('新規登録');\n    fireEvent.click(registerButton);\n\n    expect(global.mockNextRouter.push).toHaveBeenCalledWith('/traceability/register');\n  });\n\n  it('詳細表示リンクがクリックされた時に画面遷移する', async () => {\n    render(<TraceabilityList />);\n\n    await waitFor(() => {\n      const detailLink = screen.getAllByText('詳細')[0];\n      fireEvent.click(detailLink);\n      expect(global.mockNextRouter.push).toHaveBeenCalledWith('/traceability/1');\n    });\n  });\n\n  it('エラー時にエラーメッセージが表示される', async () => {\n    (global.axios.get as jest.Mock).mockRejectedValueOnce(new Error('API Error'));\n    \n    render(<TraceabilityList />);\n\n    await waitFor(() => {\n      expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument();\n    });\n  });\n\n  it('ローディング中はスピナーが表示される', async () => {\n    render(<TraceabilityList />);\n    \n    expect(screen.getByTestId('loading-spinner')).toBeInTheDocument();\n    \n    await waitFor(() => {\n      expect(screen.queryByTestId('loading-spinner')).not.toBeInTheDocument();\n    });\n  });\n\n  it('データが0件の場合に適切なメッセージが表示される', async () => {\n    (global.axios.get as jest.Mock).mockResolvedValueOnce({\n      data: {\n        items: [],\n        total: 0\n      }\n    });\n\n    render(<TraceabilityList />);\n\n    await waitFor(() => {\n      expect(screen.getByText('データが存在しません')).toBeInTheDocument();\n    });\n  });\n});\n```"
    },
    {
      "id": "BAC-008",
      "category": "データ分析",
      "handleName": "レポート生成処理",
      "description": "取引データの分析と各種レポートの生成",
      "handleProcedure": "1. 分析対象データの収集\n2. データの集計と解析\n3. グラフ・チャートの生成\n4. PDFレポートの作成\n5. レポートの保存\n6. ダウンロードURLの返却",
      "fileName": "report-generator.ts",
      "relatedScreen": "SCR-010",
      "relatedFrontendCode": "```typescript\nimport { render, screen, fireEvent, waitFor } from '@testing-library/react'\nimport { jest } from '@jest/globals'\nimport AnalyticsDashboard from '@/app/analytics/dashboard/page'\nimport userEvent from '@testing-library/user-event'\nimport '@testing-library/jest-dom'\n\n// モックデータ\nconst mockTransactionData = {\n  transactions: [\n    { id: 1, date: '2024-01-01', amount: 10000, product: 'CBD Oil' },\n    { id: 2, date: '2024-01-02', amount: 15000, product: 'CBD Cream' }\n  ],\n  salesData: {\n    totalSales: 25000,\n    averageOrderValue: 12500,\n    topProducts: ['CBD Oil', 'CBD Cream']\n  }\n}\n\n// モックコンポーネント\njest.mock('@/components/Header', () => {\n  return function MockHeader() {\n    return <div data-testid=\"mock-header\">Header</div>\n  }\n})\n\njest.mock('@/components/Sidebar', () => {\n  return function MockSidebar() {\n    return <div data-testid=\"mock-sidebar\">Sidebar</div>\n  }\n})\n\njest.mock('@/components/Charts', () => {\n  return function MockCharts({ data, type }) {\n    return <div data-testid=\"mock-charts\">{type}: {JSON.stringify(data)}</div>\n  }\n})\n\njest.mock('@/components/AnalyticsFilter', () => {\n  return function MockAnalyticsFilter({ onApply }) {\n    return (\n      <button data-testid=\"filter-apply\" onClick={() => onApply({ \n        startDate: '2024-01-01',\n        endDate: '2024-01-31'\n      })}>\n        Apply Filter\n      </button>\n    )\n  }\n})\n\n// APIモック\njest.mock('axios')\n\ndescribe('AnalyticsDashboard', () => {\n  beforeEach(() => {\n    global.axios.get.mockResolvedValue({ data: mockTransactionData })\n  })\n\n  afterEach(() => {\n    jest.clearAllMocks()\n  })\n\n  it('正しくレンダリングされること', async () => {\n    render(<AnalyticsDashboard />)\n    \n    expect(screen.getByTestId('mock-header')).toBeInTheDocument()\n    expect(screen.getByTestId('mock-sidebar')).toBeInTheDocument()\n    expect(screen.getByTestId('mock-charts')).toBeInTheDocument()\n    \n    await waitFor(() => {\n      expect(screen.getByText(/Total Sales: ¥25,000/)).toBeInTheDocument()\n    })\n  })\n\n  it('フィルター適用時にデータが更新されること', async () => {\n    render(<AnalyticsDashboard />)\n    \n    const filterButton = screen.getByTestId('filter-apply')\n    fireEvent.click(filterButton)\n    \n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith(\n        expect.stringContaining('startDate=2024-01-01')\n      )\n    })\n  })\n\n  it('エクスポートボタンクリック時にPDFがダウンロードされること', async () => {\n    global.axios.post.mockResolvedValueOnce({\n      data: { downloadUrl: 'http://example.com/report.pdf' }\n    })\n\n    render(<AnalyticsDashboard />)\n    \n    const exportButton = screen.getByText('レポートをエクスポート')\n    fireEvent.click(exportButton)\n\n    await waitFor(() => {\n      expect(global.axios.post).toHaveBeenCalledWith(\n        '/api/analytics/export',\n        expect.any(Object)\n      )\n    })\n  })\n\n  it('エラー時にエラーメッセージが表示されること', async () => {\n    global.axios.get.mockRejectedValueOnce(new Error('API Error'))\n    \n    render(<AnalyticsDashboard />)\n\n    await waitFor(() => {\n      expect(screen.getByText('データの取得に失敗しました')).toBeInTheDocument()\n    })\n  })\n\n  it('日付範囲の変更が正しく機能すること', async () => {\n    render(<AnalyticsDashboard />)\n\n    const dateRangeSelector = screen.getByRole('combobox', { name: '期間' })\n    await userEvent.selectOptions(dateRangeSelector, '30days')\n\n    await waitFor(() => {\n      expect(global.axios.get).toHaveBeenCalledWith(\n        expect.stringContaining('period=30days')\n      )\n    })\n  })\n\n  it('グラフタイプの切り替えが正しく機能すること', async () => {\n    render(<AnalyticsDashboard />)\n\n    const chartTypeButton = screen.getByRole('button', { name: '棒グラフ' })\n    fireEvent.click(chartTypeButton)\n\n    const updatedChart = await screen.findByTestId('mock-charts')\n    expect(updatedChart).toHaveTextContent('bar:')\n  })\n})\n```"
    }
  ]
}
